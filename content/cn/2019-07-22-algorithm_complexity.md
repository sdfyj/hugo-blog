---
title: "算法复杂度"
date: 2019-07-22
categories:
  - 计算机编程
tags:
  - 算法
slug: algorithm_complexity
---

一、算法：

算法是对特定问题求解步骤的一种描述，是独立存在的一种解决问题的方法和思想。它是指令的有限序列，其中每一条指令表示一个或多个操作；

此外，成为一个算法需要满足以下条件或特性：


1. **有穷性**。一个算法必须总是在执行有穷步之后结束，且每一步都可在有穷时间内完成。
2. **确定性**。算法中每一条指令必须有确切的含义读者理解时不会产生二义性。并且，在任何条件下，算法只有唯一的一条执行路径，即对于相同的输入只能得出相同的输出。
3. **可行性**。一个算法是能行的，即算法中描述的操作都是可以通过已经实现的基本运算执行有限次来实现的。
4. **输入**。零个或多个的输入。
5. **输出**。一个或多个的输出。

二、算法设计的要求

通常设计一个”好“的算法应考虑达到以下目标：

1. **正确性**。对于合法输入能够得到满足的结果；算法能够处理非法处理，并得到合理结果；算法对于边界数据和压力数据都能得到满足的结果。
2. **可读性**。算法要方便阅读，理解和交流，只有自己能看得懂，其它人都看不懂，谈何好算法。
3. **健壮性**。算法不应该产生莫名其妙的结果，一会儿正确，一会儿又是其它结果。
4. **高性价比，效率与低存储量需求**。利用最少的时间和资源得到满足要求的结果，可以通过时间复杂度和空间复杂度来判定。

三、算法复杂度

同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。算法分析的目的在于选择合适算法和改进算法。

计算机科学中，算法的时间复杂度是一个函数，它定量描述了该算法的运行时间。这是一个关于代表算法输入值的字符串的长度的函数。时间复杂度常用大`$O$`符号表述，不包括这个函数的低阶项和首项系数。使用这种方式时，时间复杂度可被称为是渐近的，它考察当输入值大小趋近无穷时的情况。

算法复杂度分为时间复杂度和空间复杂度。时间复杂度是指执行算法所需要的计算工作量；而空间复杂度是指执行这个算法所需要的内存空间。算法的复杂性体现在运行该算法时的计算机所需资源的多少上，计算机资源最重要的是时间和空间（即寄存器）资源，因此复杂度分为时间和空间复杂度。

1、时间复杂度

（1）时间频度 

一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度，记为`$T(n)$`。算法中的基本操作一般指算法中最深层循环内的语句

（2）时间复杂度

在刚才提到的时间频度中，`$n$`称为问题的规模，当`$n$`不断变化时，时间频度`$T(n)$`也会不断变化。但有时我们想知道它变化时呈现什么规律。为此，我们引入时间复杂度的概念。

一般情况下，算法中基本操作重复执行的次数是问题规模`$n$`的某个函数，用`$T(n)$`表示，若有某个辅助函数`$f(n)$`, 使得当`$n$`趋近于无穷大时，`$T(n)/f(n)$`的极限值为不等于零的常数，则称`$f(n)$`是`$T(n)$`的同数量级函数。记作`$T(n)=O(f(n))$`, 称`$O(f(n))$`为算法的渐进时间复杂度 ，简称时间复杂度。`$O$`是数量级的符号。

在各种不同算法中，若算法中语句执行次数为一个常数，则时间复杂度为`$O(1)$`。另外，在时间频度不相同时，时间复杂度有可能相同，如`$T(n)=n^2+3n+4$`与`$T(n)=4n^2+2n+1$`它们的频度不同，但时间复杂度相同，都为`$O(n^2)$`。

（3）最坏时间复杂度和平均时间复杂度 　

最坏情况下的时间复杂度称最坏时间复杂度。一般不特别说明，讨论的时间复杂度均是最坏情况下的时间复杂度。 这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的上界，分析最坏的情况以估算算法指向时间的一个上界。这就保证了算法的运行时间不会比任何更长。

在最坏情况下的时间复杂度为`$T(n)=O(n)$`，它表示对于任何输入实例,该算法的运行时间不可能大于`$O(n)$`。 平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，算法的期望运行时间。

按数量级递增排列，常见的时间复杂度有：

| 常数阶 | 对数阶 | 线性阶|线性对数阶|平方阶|立方阶|`$k$`次方阶|指数阶|
| :-----| :----| :----| :----| :----| :----| :----| :----| 
| `$O(1)$` | `$O(logn)$` |`$O(n)$`|`$O(nlogn)$`|`$O(n^2)$`|`$O(n^3)$`|`$O(n^k)$`|`$O(2^n)$`|

`$$O(2^n)<O(n!)<O(n^n)$$`

随着问题规模`$n$`的不断增大，上述时间复杂度不断增大，算法的执行效率越低。

时间复杂度的分析方法：

1. 时间复杂度就是函数中基本操作所执行的次数
2. 一般默认的是最坏时间复杂度，即分析最坏情况下所能执行的次数
3. 忽略掉常数项
4. 关注运行时间的增长趋势，关注函数式中增长最快的表达式，忽略系数
5. 计算时间复杂度是估算随着`$n$`的增长函数执行次数的增长趋势
6. 递归算法的时间复杂度为：递归总次数 * 每次递归中基本操作所执行的次数

计算方法

1. 一般情况下，算法中基本操作重复执行的次数是问题规模`$n$`的某个函数，用`$T(n)$`表示，若有某个辅助函数`$f(n)$`, 使得当`$n$`趋近于无穷大时，`$T(n)/f(n)$`的极限值为不等于零的常数，则称`$f(n)$`是`$T(n)$`的同数量级函数。记作`$T(n)=O(f(n))$`, 称`$O(f(n))$`为算法的渐进时间复杂度 ，简称时间复杂度。`$O$`是数量级的符号。分析：随着规模`$n$`的增大，算法执行的时间的增长率和`$f(n)$`的增长率成正比，所以`$f(n)$`越小，算法的时间复杂度越低，算法的效率越高。	

2. 在计算时间复杂度的时候，先找出算法的基本操作，然后根据相应的各语句确定它的执行次数，再找出`$T(n)$`的同数量级函数`$f(n)$`，即`$T(n)/f(n)$`求极限可得到一常数`$c$`，则时间复杂度`$T(n)=O(f(n))$`。如有`$T(n)=n^2+n^3$`，则可以确定`$f(n)=n^3$`为`$T(n)$`的同数量级函数,则该算法的时间复杂度为`$T(n)=O(n^3)$`。

3. 时间复杂度比较简单的计算方法是：看看有几重for循环，只有一重则时间复杂度为`$O(n)$`，二重则为`$O(n^2)$`，依此类推，如果有二分则为`$O(logn)$`，二分例如快速幂、二分查找，如果一个for循环套一个二分，那么时间复杂度则为`$O(nlogn)$`。

空间复杂度：

算法的空间复杂度并不是计算实际占用的空间，而是计算整个算法的辅助空间单元的个数。算法的空间复杂度`$S(n)$`定义为该算法所耗费空间的数量级。

`$S(n)=O(f(n))$`若算法执行时所需要的辅助空间相对于输入数据量`$n$`而言是一个常数，则称这个算法的辅助空间为`$O(1)$`；递归算法的空间复杂度为递归深度N*每次递归所要的辅助空间， 如果每次递归所需的辅助空间是常数，则递归的空间复杂度是`$O(N)$`。

空间复杂度的分析方法：

一个算法的空间复杂度`$S(n)$`定义为该算法所耗费的存储空间，它也是问题规模`$n$`的函数。空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度。

一个算法在计算机存储器上所占用的存储空间，包括存储算法本身所占用的存储空间，算法的输入输出数据所占用的存储空间和算法在运行过程中临时占用的存储空间这三个方面。

一个算法的空间复杂度只考虑在运行过程中为局部变量分配的存储空间的大小，它包括为参数表中形参变量分配的存储空间和为在函数体中定义的局部变量分配的存储空间两个部分。

算法的空间复杂度一般也以数量级的形式给出。如当一个算法的空间复杂度为一个常量，即不随被处理数据量`$n$`的大小而改变时，可表示为`$O(1)$`；当一个算法的空间复杂度与以`$2$`为底的`$n$`的对数成正比时，可表示为`$O(log_2 n)$`；当一个算法的空间复杂度与`$n$`成线性比例关系时，可表示为`$O(n)$`。若形参为数组，则只需要为它分配一个存储由实参传送来的一个地址指针的空间，即一个机器字长空间；若形参为引用方式，则也只需要为其分配存储一个地址的空间，用它来存储对应实参变量的地址，以便由系统自动引用实参变量。

空间复杂度补充

一个程序的空间复杂度是指运行完一个程序所需内存的大小。利用程序的空间复杂度，可以对程序的运行所需要的内存多少有个预先估计。一个程序执行时除了需要存储空间和存储本身所使用的指令、常数、变量和输入数据外，还需要一些对数据进行操作的工作单元和存储一些为现实计算所需信息的辅助空间。程序执行时所需存储空间包括以下两部分。

（1）固定部分。这部分空间的大小与输入/输出的数据的个数多少、数值无关。主要包括指令空间（即代码空间）、数据空间（常量、简单变量）等所占的空间。这部分属于静态空间。

（2）可变空间，这部分空间的主要包括动态分配的空间，以及递归栈所需的空间等。这部分的空间大小与算法有关。

一个算法所需的存储空间用`$f(n)$`表示。`$S(n)=O(f(n))$` 其中n为问题的规模，`$S(n)$`表示空间复杂度。

时间与空间复杂度比较

对于一个算法，其时间复杂度和空间复杂度往往是相互影响的。当追求一个较好的时间复杂度时，可能会使空间复杂度的性能变差，即可能导致占用较多的存储空间；反之，当追求一个较好的空间复杂度时，可能会使时间复杂度的性能变差，即可能导致占用较长的运行时间。

另外，算法的所有性能之间都存在着或多或少的相互影响。因此，当设计一个算法（特别是大型算法）时，要综合考虑算法的各项性能，算法的使用频率，算法处理的数据量的大小，算法描述语言的特性，算法运行的机器系统环境等各方面因素，才能够设计出比较好的算法。算法的时间复杂度和空间复杂度合称为算法的复杂度。

常用的算法的时间复杂度和空间复杂度：

| 排序法 | 平均时间 | 最差情形 |稳定度|额外空间|备注|
| :-----| :----| :----| :----| :----| :----|
| 冒泡 | `$O(n^2)$` |`$O(n^2)$`|稳定|`$O(1)$`|`$n$`较小时较好|
| 交换 | `$O(n^2)$` |`$O(n^2)$`|不稳定|`$O(1)$`|`$n$`较小时较好|
| 选择 | `$O(n^2)$` |`$O(n^2)$`|不稳定|`$O(1)$`|`$n$`较小时较好|
| 插入 | `$O(n^2)$` |`$O(n^2)$`|稳定|`$O(1)$`|大部分已排序时较好|
| 基数 | `$O(log_R B)$` |`$O(log_R B)$`|稳定|`$O(n)$`|B是真数(0-9)，R是基数(个十百)|
| Shell | `$O(nlogn)$` |`$O(n^s) 1<s<2$`|不稳定|`$O(1)$`|`$s$`是所选分组|
| 快速 | `$O(nlogn)$` |`$O(n^2)$`|不稳定|`$O(nlogn)$`|`$n$`较大时较好|
| 归并 | `$O(nlogn)$` |`$O(nlogn)$`|稳定|`$O(1)$`|`$n$`较大时较好|
| 堆 | `$O(nlogn)$` |`$O(nlogn)$`|不稳定|`$O(1)$`|`$n$`较大时较好|




[参考](https://www.cnblogs.com/zh605929205/p/7442317.html)